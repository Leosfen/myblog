(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{140:function(t,e,r){"use strict";r.r(e);var a=r(0),n=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h4",{attrs:{id:"题目：zk队列管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#题目：zk队列管理","aria-hidden":"true"}},[t._v("#")]),t._v(" "),r("strong",[t._v("题目")]),t._v("：zk队列管理")]),t._v(" "),r("h4",{attrs:{id:"参考答案："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考答案：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),r("strong",[t._v("参考答案")]),t._v("：")]),t._v(" "),r("p",[t._v("两种类型的队列：\n1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。\n2、队列按照 FIFO 方式进行入队和出队操作。\n第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。\n第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。")])])},[],!1,null,null,null);e.default=n.exports}}]);