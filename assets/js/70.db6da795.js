(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{175:function(t,a,e){"use strict";e.r(a);var r=e(0),c=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"题目：zookeeper通知机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目：zookeeper通知机制","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("题目")]),t._v("：zookeeper通知机制")]),t._v(" "),e("h4",{attrs:{id:"参考答案："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考答案：","aria-hidden":"true"}},[t._v("#")]),t._v(" "),e("strong",[t._v("参考答案")]),t._v("：")]),t._v(" "),e("p",[t._v("client端会对某个znode建立一个watcher事件，当该znode发生变化时，zk会主动通知watch这个znode的client，然后client根据znode的变化来做出业务上的改变等。")]),t._v(" "),e("h4",{attrs:{id:"watcher的特点："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watcher的特点：","aria-hidden":"true"}},[t._v("#")]),t._v(" watcher的特点：")]),t._v(" "),e("ul",[e("li",[t._v("轻量级：一个callback函数。")]),t._v(" "),e("li",[t._v("异步性：不会block正常的读写请求。")]),t._v(" "),e("li",[t._v("主动推送：Watch被触发时，由Zookeeper服务端主动将更新推送给客户端。")]),t._v(" "),e("li",[t._v("一次性：数据变化时，Watch只会被触发一次。如果客户端想得到后续更新的通知，必须要在 Watch 被触发后重新注册一个 Watch。")]),t._v(" "),e("li",[t._v("仅通知：仅通知变更类型，不附带变更后的结果。")]),t._v(" "),e("li",[t._v("顺序性：如果多个更新触发了多个Watch，那 Watch 被触发的顺序与更新顺序一致。")])]),t._v(" "),e("h4",{attrs:{id:"使用watch的注意事项："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用watch的注意事项：","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用watch的注意事项：")]),t._v(" "),e("ul",[e("li",[t._v("由于watcher是一次性的，所以需要自己去实现永久watch")]),t._v(" "),e("li",[t._v("如果被watch的节点频繁更新，会出现“丢数据”的情况")]),t._v(" "),e("li",[t._v("watcher数量过多会导致性能下降")])])])},[],!1,null,null,null);a.default=c.exports}}]);