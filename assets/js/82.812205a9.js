(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{196:function(e,r,a){"use strict";a.r(r);var s=a(0),t=Object(s.a)({},function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h4",{attrs:{id:"题目：zookeeper是如何选举leader的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#题目：zookeeper是如何选举leader的","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("题目")]),e._v("：zookeeper是如何选举Leader的?")]),e._v(" "),a("h4",{attrs:{id:"参考答案："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考答案：","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("参考答案")]),e._v("：")]),e._v(" "),a("p",[e._v("当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。")]),e._v(" "),a("p",[e._v("1、Zookeeper选主流程(basic paxos)\n（1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；\n（2）选举线程首先向所有Server发起一次询问(包括自己)；\n（3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；\n（4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；\n（5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。")]),e._v(" "),a("img",{attrs:{src:"zk_zab_basic_paxos.png"}}),e._v(" "),a("p",[e._v("2、Zookeeper选主流程(fast paxos)\nfast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。")]),e._v(" "),a("img",{attrs:{src:"zk_zab_fast_paxos.png"}})])},[],!1,null,null,null);r.default=t.exports}}]);