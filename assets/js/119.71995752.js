(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{126:function(n,e,t){"use strict";t.r(e);var r=t(0),a=Object(r.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h4",{attrs:{id:"题目：最大频率栈。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目：最大频率栈。","aria-hidden":"true"}},[n._v("#")]),n._v(" "),t("strong",[n._v("题目")]),n._v("：最大频率栈。")]),n._v(" "),t("p",[n._v("实现 FreqStack，模拟类似栈的数据结构的操作的一个类。FreqStack 有两个函数：\npush(int x)，将整数 x 推入栈中。pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。\n◼ 示例：\npush [5,7,5,7,4,5]\npop() -> 返回 5，因为 5 是出现频率最高的。\n栈变成\n[5,7,5,7,4]。\npop() -> 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈\n顶。\n栈变成 [5,7,5,4]。\npop() -> 返回 5 。\n栈变成 [5,7,4]。\npop() -> 返回 4 。\n栈变成 [5,7]。")]),n._v(" "),t("h4",{attrs:{id:"出题人：阿里巴巴出题专家：屹平／阿里云视频云边缘计算高级技术专家"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#出题人：阿里巴巴出题专家：屹平／阿里云视频云边缘计算高级技术专家","aria-hidden":"true"}},[n._v("#")]),n._v(" "),t("strong",[n._v("出题人")]),n._v("：阿里巴巴出题专家：屹平／阿里云视频云边缘计算高级技术专家")]),n._v(" "),t("h4",{attrs:{id:"参考答案："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考答案：","aria-hidden":"true"}},[n._v("#")]),n._v(" "),t("strong",[n._v("参考答案")]),n._v("：")]),n._v(" "),t("p",[n._v("令 freq 作为 x 的出现次数的映射 Map。")]),n._v(" "),t("p",[n._v("此外 maxfreq，即栈中任意元素的当前最大频率，因为我们必须弹出频率最高的元素。")]),n._v(" "),t("p",[n._v("当前主要的问题就变成了：在具有相同的（最大）频率的元素中，怎么判断那个元素是最新的？我们可以使用栈来查询这一信息：靠近栈顶的元素总是相对更新一些。")]),n._v(" "),t("p",[n._v("为此，我们令 group 作为从频率到具有该频率的元素的映射。到目前，我们已经实现了 FreqStack 的所有必要的组件。")]),n._v(" "),t("p",[n._v("算法：")]),n._v(" "),t("p",[n._v("实际上，作为实现层面上的一点细节，如果 x 的频率为 f，那么我们将获取在所有 group[i] (i <= f) 中的 x,而不仅仅是栈顶的那个。这是因为每个 group[i] 都会存储与第 i 个 x 副本相关的信息。")]),n._v(" "),t("p",[n._v("最后，我们仅仅需要如上所述维持 freq，group，以及 maxfreq。")]),n._v(" "),t("p",[t("strong",[n._v("参考代码")]),n._v("*：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class FreqStack {\n    Map<Integer, Integer> freq;\n    Map<Integer, Stack<Integer>> group;\n    int maxfreq;\n\n    public FreqStack() {\n        freq = new HashMap();\n        group = new HashMap();\n        maxfreq = 0;\n    }\n    \n    public void push(int x) {\n        int f = freq.getOrDefault(x, 0) + 1;\n        freq.put(x, f);\n        if (f > maxfreq) maxfreq = f;\n        group.computeIfAbsent(f, z-> new Stack()).push(x);\n    }\n    \n    public int pop() {\n        int x = group.get(maxfreq).pop();\n        freq.put(x, freq.get(x) - 1);\n        if (group.get(maxfreq).size() == 0)\n        maxfreq--;\n        return x;\n    }\n}\n")])])])])},[],!1,null,null,null);e.default=a.exports}}]);